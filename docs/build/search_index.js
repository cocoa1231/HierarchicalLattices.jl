var documenterSearchIndex = {"docs":
[{"location":"#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"#Diamond-Lattice-Generation","page":"API Reference","title":"Diamond Lattice Generation","text":"","category":"section"},{"location":"","page":"API Reference","title":"API Reference","text":"Modules = [HierarchicalLattices]\nPages   = [\"DiamondLattices/Lattice.jl\", \"DiamondLattices/StackedLattice.jl\"]\nOrder   = [:type, :method, :function]\nPrivate = false","category":"page"},{"location":"#HierarchicalLattices.DiamondLattice","page":"API Reference","title":"HierarchicalLattices.DiamondLattice","text":"Main type for a diamond lattice. Takes four fields\n\ngeneration: The order or generation of the lattice.\ninitial_state: The initial state of the lattice at time of creation.\nfinal_state: Final state of the lattice after MCMC simulation.\ninteraction_weight: Strength of the bonds of the lattice.\n\nNo type restrictions are imposed on the fields (expect to be changed). There are two external constructors.\n\nDiamondLattice(G::MetaGraph, o::Integer): Construct a diamond lattice with initiial and final states G and o. The strength of the lattice will be G.defaultweight. Note: this will create a deepcopy of G.\nDiamondLattice(G::MetaGraph, o::Integer, latticeweight::Number):  Construct a diamond lattice with initiial and final states G and o. The strength of the lattice will be latticeweight. Note: this will create a deepcopy of G.\n\n\n\n\n\n","category":"type"},{"location":"#HierarchicalLattices.diamond_ising_lattice-Tuple{Int64, Int64, Symbol}","page":"API Reference","title":"HierarchicalLattices.diamond_ising_lattice","text":"Generates an arbitrary order diamond Ising lattice given an initial state where the initial state can be :zero or :infty. This function does not calculate the location of every spin. Inputs:\n\norder::Int64: Order of the lattice to generate.\nb::Int64: Branching number of the lattice.\nshowprogress (default false): Add a progress bar. \ngc_freq (default 0.): Since the function iterates over every edge and adds new nodes with temporary variables at each iteration, for larger lattices this parameter can be helpful to keep memory usage down. Setting this to anything above 0 disables multithreading. At every iteration, run the garbage collector with the probability gc_freq. Any value above 1 will indicate running this at every iteration.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalLattices.diamond_ising_lattice-Tuple{Integer, Symbol}","page":"API Reference","title":"HierarchicalLattices.diamond_ising_lattice","text":"Generates an arbitrary order diamond Ising lattice given an initial state where the initial state can be :zero or :infty. This method will calculate the location of every spin as well for plotting. Inputs:\n\norder::Integer: Order of lattice to generate.\nstate::Symbol: Can either be :zero for all spins pointing up (+1) or :infty for all spins pointing randomly.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalLattices.diamond_lattice-Tuple{Int64, Int64}","page":"API Reference","title":"HierarchicalLattices.diamond_lattice","text":"Generates an arbitrary order diamond lattice. This function does not calculate physical locations of every new point. Inputs:\n\norder::Int64: Order of the lattice to create.\nb::Int64: Branching number of the lattice.\nshowprogress (default false): Add a progress bar. \ngc_freq (default 0.): Since the function iterates over every edge and adds new nodes with temporary variables at each iteration, for larger lattices this parameter can be helpful to keep memory usage down. Setting this to anything above 0 disables multithreading. At every iteration, run the garbage collector with the probability gc_freq. Any value above 1 will indicate running this at every iteration.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalLattices.diamond_lattice-Tuple{Integer}","page":"API Reference","title":"HierarchicalLattices.diamond_lattice","text":"Generates an arbitrary order diamond lattice with b = 2. Thus function will calculate the location of every spin. The location of every new spin will be scaled by 0.5^o where o is the order of the spin. Inputs:\n\norder::Integer: Order of the lattice to generate\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalLattices.diamond_order_zero_transform!-Tuple{Any, Any}","page":"API Reference","title":"HierarchicalLattices.diamond_order_zero_transform!","text":"Takes a lattice graph and an edge and applies b = 2 diamond transform. Thus function will also calculate the physical locations of the new spins with respect to locations of the old one, and thus should only be used for visual demonstration purposes. It is, otherwise, quite memory inefficient. Inputs for the function are:\n\nlattice: The MetaGraph to apply the transformation to.\nedge: The edge to apply the transformation to.\nscale (default = 1): How much to scale the locations of the new bonds by. A scale of 1 indicates that the distance between the new bond and edge should be equal to the length of edge.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalLattices.make_diamond_lattice0-Tuple{}","page":"API Reference","title":"HierarchicalLattices.make_diamond_lattice0","text":"Creates an order 0, b = 2 diamond lattice with spin values set to false and locations of the spins at 1im and -1im. Returns a MetaGraph.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalLattices.StackedDiamondLattice","page":"API Reference","title":"HierarchicalLattices.StackedDiamondLattice","text":"Represents a stacked diamond lattice with anisotropic bond strength in the stacking and \"spacial\" direction. Fields:\n\ngeneration: Lattice generation in the spacial direction.\nstackingweight: Bond strength in the stacking direction.\ninitial_state: Initial state at the time of construction.\nfinal_state: Final state after MCMC evolution.\nedgeweightmap: Maps vertex index to a dictionary mapping the edge weight to neighbouring spins.\n\nApart from the inner constructor, this type also has an outer constructor.\n\nStackedDiamondLattice(order, depth, stackingweight, initstate) - Create a stacked diamond lattice with spacial part made of diamond lattice with the given order, depth and stacking weight. Additionally, each spacial lattice in the spacial direction will have an initial state initstate which can be :zero or :infty.\n\n\n\n\n\n","category":"type"},{"location":"#Metropolis-MCMC-Evolution","page":"API Reference","title":"Metropolis MCMC Evolution","text":"","category":"section"},{"location":"","page":"API Reference","title":"API Reference","text":"Modules = [HierarchicalLattices]\nPages   = [\"DiamondLattices/Metropolis.jl\"]\nOrder   = [:type, :method, :function]\nPrivate = false","category":"page"},{"location":"#HierarchicalLattices.IsingData","page":"API Reference","title":"HierarchicalLattices.IsingData","text":"Main type used by the metropolis! function. The fields are:\n\nlattice: Lattice to evolve.\nmagnetization_history::Vector{Float64}: Every index i corresponds to the magnetization at the state i.\ninternalenergy_history::Vector{Float64}: Every index i corresponds to the internal energy at the state i.\nspinflip_history::Vector:  Every index i corresponds to the spin flipped in the previous Metropolis step i-1.\n\n\n\n\n\n","category":"type"},{"location":"#HierarchicalLattices.fill_data!-Tuple{IsingData, Symbol}","page":"API Reference","title":"HierarchicalLattices.fill_data!","text":"Fill the internal energy or magnetization history of a lattice evolved using the metropolis! function. Inputs:\n\ndata::IsingData: Lattice to fill data for.\nvariable::Symbol: Which variable to fill. Possible values are :U for internal energy and :M for magnetization.\nshowprogress (default false): Add a progress bar.\nprogressoutput (default stdout): Write the progress bar output to this IO.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalLattices.metropolis!-Tuple{IsingData, Integer, Float64}","page":"API Reference","title":"HierarchicalLattices.metropolis!","text":"Evolves the system the given number of steps.\n\ndata::IsingData: Lattice to evolve.\nsteps::Integer: Number of steps to evolve the system for.\nT::Float64: Temperature at which to evolve the system.\nshowprogress (default false): Add a progress bar.\nprogressoutput (default stdout): Write the progress bar output to this IO.\n\n\n\n\n\n","category":"method"},{"location":"#Cluster-(Wolff)-MCMC-Evolution","page":"API Reference","title":"Cluster (Wolff) MCMC Evolution","text":"","category":"section"},{"location":"","page":"API Reference","title":"API Reference","text":"Modules = [HierarchicalLattices]\nPages   = [\"DiamondLattices/Cluster.jl\"]\nOrder   = [:type, :method, :function]\nPrivate = false","category":"page"},{"location":"#HierarchicalLattices.WolffData","page":"API Reference","title":"HierarchicalLattices.WolffData","text":"Main type used by the wolff! function. Fields:\n\nlattice::T: Lattice to evolve using the Wolff algorithm.\nmagnetization_history::Vector{Float64}: Every index i corresponds to the magnetization of the system at the wolff step i*saveinterval.\ninternalenergy_history::Vector{Float64}: Every index i corresponds to the internal energy of the system at the wolff step i*saveinterval.\nsaveinterval::Int64: Save the state of the system after this many steps.\nthermalization_steps::Int64: Steps the system for this many steps before  starting data collection.\n\n\n\n\n\n","category":"type"},{"location":"#HierarchicalLattices.wolff!-Union{Tuple{L}, Tuple{WolffData{L}, Any, Any}} where L","page":"API Reference","title":"HierarchicalLattices.wolff!","text":"Run the Wolff algorithm for a given number of steps at a temperature. Inputs:\n\nWD::WolffData{L} WolffData with lattice type L.\nnsteps: Number of steps to evolve the system for.\nT: Temperature at which to evolve the system.\nshowprogress (default false): Add a progress bar.\nverbose (default false): Look at the argument name.\nprogressoutput (default stdout): Write the progress output to the given IO.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalLattices.wolffstep!-Tuple{DiamondLattice, Float64, Dictionaries.Dictionary{Int64, Vector{Int64}}}","page":"API Reference","title":"HierarchicalLattices.wolffstep!","text":"Step the system for one step of the Wolff algorithm. Inputs:\n\nlattice::DiamondLattice: Lattice to evolve. This function is specialized for the diamond lattice.\nP_add::Float64: Probability of adding the a spin to the cluster.\nadjacentmap::Dictionary{Int64, Vector{Int64}}: Adjacency map of the system. Will be changed to use the adjacency matrix.\n\n\n\n\n\n","category":"method"},{"location":"#HierarchicalLattices.wolffstep!-Tuple{StackedDiamondLattice, Dictionaries.Dictionary{Float64, Float64}, Dictionaries.Dictionary{Int64, Vector{Int64}}}","page":"API Reference","title":"HierarchicalLattices.wolffstep!","text":"Step the system for one step of the Wolff algorithm. Inputs:\n\nlattice::StackedDiamondLattice: Lattice to evolve. This function is specialized for the stacked diamond lattice.\nprobdict::Dictionary{Float64, Float64}: Probability of adding the a spin to the cluster. Maps the bond (or edge) strength to the probability.\nadjacentmap::Dictionary{Int64, Vector{Int64}}: Adjacency map of the system. Will be changed to use the adjacency matrix.\n\n\n\n\n\n","category":"method"}]
}
