var documenterSearchIndex = {"docs":
[{"location":"apiref.html#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"apiref.html#Diamond-Lattice-Generation","page":"API Reference","title":"Diamond Lattice Generation","text":"","category":"section"},{"location":"apiref.html","page":"API Reference","title":"API Reference","text":"Modules = [HierarchicalLattices]\nPages   = [\"DiamondLattices/Lattice.jl\", \"DiamondLattices/StackedLattice.jl\"]\nOrder   = [:type, :method, :function]\nPrivate = true","category":"page"},{"location":"apiref.html#HierarchicalLattices.DiamondLattice","page":"API Reference","title":"HierarchicalLattices.DiamondLattice","text":"Main type for a diamond lattice. Takes four fields\n\ngeneration: The order or generation of the lattice.\ninitial_state: The initial state of the lattice at time of creation.\nfinal_state: Final state of the lattice after MCMC simulation.\ninteraction_weight: Strength of the bonds of the lattice.\n\nNo type restrictions are imposed on the fields (expect to be changed). There are two external constructors.\n\nDiamondLattice(G::MetaGraph, o::Integer): Construct a diamond lattice with initiial and final states G and o. The strength of the lattice will be G.defaultweight. Note: this will create a deepcopy of G.\nDiamondLattice(G::MetaGraph, o::Integer, latticeweight::Number):  Construct a diamond lattice with initiial and final states G and o. The strength of the lattice will be latticeweight. Note: this will create a deepcopy of G.\n\n\n\n\n\n","category":"type"},{"location":"apiref.html#HierarchicalLattices.diamond_ising_lattice-Tuple{Int64, Int64, Symbol}","page":"API Reference","title":"HierarchicalLattices.diamond_ising_lattice","text":"Generates an arbitrary order diamond Ising lattice given an initial state where the initial state can be :zero or :infty. This function does not calculate the location of every spin. Inputs:\n\norder::Int64: Order of the lattice to generate.\nb::Int64: Branching number of the lattice.\nshowprogress (default false): Add a progress bar. \ngc_freq (default 0.): Since the function iterates over every edge and adds new nodes with temporary variables at each iteration, for larger lattices this parameter can be helpful to keep memory usage down. Setting this to anything above 0 disables multithreading. At every iteration, run the garbage collector with the probability gc_freq. Any value above 1 will indicate running this at every iteration.\n\n\n\n\n\n","category":"method"},{"location":"apiref.html#HierarchicalLattices.diamond_ising_lattice-Tuple{Integer, Symbol}","page":"API Reference","title":"HierarchicalLattices.diamond_ising_lattice","text":"Generates an arbitrary order diamond Ising lattice given an initial state where the initial state can be :zero or :infty. This method will calculate the location of every spin as well for plotting. Inputs:\n\norder::Integer: Order of lattice to generate.\nstate::Symbol: Can either be :zero for all spins pointing up (+1) or :infty for all spins pointing randomly.\n\n\n\n\n\n","category":"method"},{"location":"apiref.html#HierarchicalLattices.diamond_lattice-Tuple{Int64, Int64}","page":"API Reference","title":"HierarchicalLattices.diamond_lattice","text":"Generates an arbitrary order diamond lattice. This function does not calculate physical locations of every new point. Inputs:\n\norder::Int64: Order of the lattice to create.\nb::Int64: Branching number of the lattice.\nshowprogress (default false): Add a progress bar. \ngc_freq (default 0.): Since the function iterates over every edge and adds new nodes with temporary variables at each iteration, for larger lattices this parameter can be helpful to keep memory usage down. Setting this to anything above 0 disables multithreading. At every iteration, run the garbage collector with the probability gc_freq. Any value above 1 will indicate running this at every iteration.\n\n\n\n\n\n","category":"method"},{"location":"apiref.html#HierarchicalLattices.diamond_lattice-Tuple{Integer}","page":"API Reference","title":"HierarchicalLattices.diamond_lattice","text":"Generates an arbitrary order diamond lattice with b = 2. Thus function will calculate the location of every spin. The location of every new spin will be scaled by 0.5^o where o is the order of the spin. Inputs:\n\norder::Integer: Order of the lattice to generate\n\n\n\n\n\n","category":"method"},{"location":"apiref.html#HierarchicalLattices.diamond_order_zero_transform!-Tuple{Any, Any}","page":"API Reference","title":"HierarchicalLattices.diamond_order_zero_transform!","text":"Takes a lattice graph and an edge and applies b = 2 diamond transform. Thus function will also calculate the physical locations of the new spins with respect to locations of the old one, and thus should only be used for visual demonstration purposes. It is, otherwise, quite memory inefficient. Inputs for the function are:\n\nlattice: The MetaGraph to apply the transformation to.\nedge: The edge to apply the transformation to.\nscale (default = 1): How much to scale the locations of the new bonds by. A scale of 1 indicates that the distance between the new bond and edge should be equal to the length of edge.\n\n\n\n\n\n","category":"method"},{"location":"apiref.html#HierarchicalLattices.make_diamond_lattice0-Tuple{}","page":"API Reference","title":"HierarchicalLattices.make_diamond_lattice0","text":"Creates an order 0, b = 2 diamond lattice with spin values set to false and locations of the spins at 1im and -1im. Returns a MetaGraph.\n\n\n\n\n\n","category":"method"},{"location":"apiref.html#HierarchicalLattices.order_zero_diamond_lattice-Tuple{}","page":"API Reference","title":"HierarchicalLattices.order_zero_diamond_lattice","text":"Creates an order 0 diamond lattice. Does not calculate the location of the spins.\n\n\n\n\n\n","category":"method"},{"location":"apiref.html#HierarchicalLattices.raise_order_diamond!-Tuple{Any, Any}","page":"API Reference","title":"HierarchicalLattices.raise_order_diamond!","text":"Raise order of diamond lattice. This will apply transform_edge_diamond! to all edges of the lattice, given a b. Inputs:\n\nlattice: MetaGraph to apply the transformation to.\nb: Number of new branches created for every edge.\nshowprogress (default false): Add a progress bar.\ngc_freq (default 0.01): Since the function iterates over every edge and adds new nodes with temporary variables at each iteration, for larger lattices this parameter can be helpful to keep memory usage down. Setting this to anything above 0 disables multithreading. At every iteration, run the garbage collector with the probability gc_freq. Any value above 1 will indicate running this at every iteration.\n\n\n\n\n\n","category":"method"},{"location":"apiref.html#HierarchicalLattices.transform_edge_diamond!-Tuple{Any, Any, Any}","page":"API Reference","title":"HierarchicalLattices.transform_edge_diamond!","text":"Takes a lattice graph and an edge and applies diamond transform. This will apply the diamond transform with arbitrary b. Inputs:\n\nlattice: MetaGraph lattice to apply the transformation to.\nedge: Edge to apply the transformation to.\nb: Number of new branches created.\n\n\n\n\n\n","category":"method"},{"location":"apiref.html#HierarchicalLattices.StackedDiamondLattice","page":"API Reference","title":"HierarchicalLattices.StackedDiamondLattice","text":"Represents a stacked diamond lattice with anisotropic bond strength in the stacking and \"spacial\" direction. Fields:\n\ngeneration: Lattice generation in the spacial direction.\nstackingweight: Bond strength in the stacking direction.\ninitial_state: Initial state at the time of construction.\nfinal_state: Final state after MCMC evolution.\nedgeweightmap: Maps vertex index to a dictionary mapping the edge weight to neighbouring spins.\n\nApart from the inner constructor, this type also has an outer constructor.\n\nStackedDiamondLattice(order, depth, stackingweight, initstate) - Create a stacked diamond lattice with spacial part made of diamond lattice with the given order, depth and stacking weight. Additionally, each spacial lattice in the spacial direction will have an initial state initstate which can be :zero or :infty.\n\n\n\n\n\n","category":"type"},{"location":"apiref.html#Metropolis-MCMC-Evolution","page":"API Reference","title":"Metropolis MCMC Evolution","text":"","category":"section"},{"location":"apiref.html","page":"API Reference","title":"API Reference","text":"Modules = [HierarchicalLattices]\nPages   = [\"DiamondLattices/Metropolis.jl\"]\nOrder   = [:type, :method, :function]\nPrivate = true","category":"page"},{"location":"apiref.html#HierarchicalLattices.IsingData","page":"API Reference","title":"HierarchicalLattices.IsingData","text":"Main type used by the metropolis! function. The fields are:\n\nlattice: Lattice to evolve.\nmagnetization_history::Vector{Float64}: Every index i corresponds to the magnetization at the state i.\ninternalenergy_history::Vector{Float64}: Every index i corresponds to the internal energy at the state i.\nspinflip_history::Vector:  Every index i corresponds to the spin flipped in the previous Metropolis step i-1.\n\n\n\n\n\n","category":"type"},{"location":"apiref.html#HierarchicalLattices.fill_data!-Tuple{IsingData, Symbol}","page":"API Reference","title":"HierarchicalLattices.fill_data!","text":"Fill the internal energy or magnetization history of a lattice evolved using the metropolis! function. Inputs:\n\ndata::IsingData: Lattice to fill data for.\nvariable::Symbol: Which variable to fill. Possible values are :U for internal energy and :M for magnetization.\nshowprogress (default false): Add a progress bar.\nprogressoutput (default stdout): Write the progress bar output to this IO.\n\n\n\n\n\n","category":"method"},{"location":"apiref.html#HierarchicalLattices.metropolis!-Tuple{IsingData, Integer, Float64}","page":"API Reference","title":"HierarchicalLattices.metropolis!","text":"Evolves the system the given number of steps.\n\ndata::IsingData: Lattice to evolve.\nsteps::Integer: Number of steps to evolve the system for.\nT::Float64: Temperature at which to evolve the system.\nshowprogress (default false): Add a progress bar.\nprogressoutput (default stdout): Write the progress bar output to this IO.\n\n\n\n\n\n","category":"method"},{"location":"apiref.html#Cluster-(Wolff)-MCMC-Evolution","page":"API Reference","title":"Cluster (Wolff) MCMC Evolution","text":"","category":"section"},{"location":"apiref.html","page":"API Reference","title":"API Reference","text":"Modules = [HierarchicalLattices]\nPages   = [\"DiamondLattices/Cluster.jl\"]\nOrder   = [:type, :method, :function]\nPrivate = true","category":"page"},{"location":"apiref.html#HierarchicalLattices.WolffData","page":"API Reference","title":"HierarchicalLattices.WolffData","text":"Main type used by the wolff! function. Fields:\n\nlattice::T: Lattice to evolve using the Wolff algorithm.\nmagnetization_history::Vector{Float64}: Every index i corresponds to the magnetization of the system at the wolff step i*saveinterval.\ninternalenergy_history::Vector{Float64}: Every index i corresponds to the internal energy of the system at the wolff step i*saveinterval.\nsaveinterval::Int64: Save the state of the system after this many steps.\nthermalization_steps::Int64: Steps the system for this many steps before  starting data collection.\n\n\n\n\n\n","category":"type"},{"location":"apiref.html#HierarchicalLattices.wolff!-Union{Tuple{L}, Tuple{WolffData{L}, Any, Any}} where L","page":"API Reference","title":"HierarchicalLattices.wolff!","text":"Run the Wolff algorithm for a given number of steps at a temperature. Inputs:\n\nWD::WolffData{L} WolffData with lattice type L.\nnsteps: Number of steps to evolve the system for.\nT: Temperature at which to evolve the system.\nshowprogress (default false): Add a progress bar.\nverbose (default false): Look at the argument name.\nprogressoutput (default stdout): Write the progress output to the given IO.\n\n\n\n\n\n","category":"method"},{"location":"apiref.html#HierarchicalLattices.wolffstep!-Tuple{DiamondLattice, Float64, Dictionaries.Dictionary{Int64, Vector{Int64}}}","page":"API Reference","title":"HierarchicalLattices.wolffstep!","text":"Step the system for one step of the Wolff algorithm. Inputs:\n\nlattice::DiamondLattice: Lattice to evolve. This function is specialized for the diamond lattice.\nP_add::Float64: Probability of adding the a spin to the cluster.\nadjacentmap::Dictionary{Int64, Vector{Int64}}: Adjacency map of the system. Will be changed to use the adjacency matrix.\n\n\n\n\n\n","category":"method"},{"location":"apiref.html#HierarchicalLattices.wolffstep!-Tuple{StackedDiamondLattice, Dictionaries.Dictionary{Float64, Float64}, Dictionaries.Dictionary{Int64, Vector{Int64}}}","page":"API Reference","title":"HierarchicalLattices.wolffstep!","text":"Step the system for one step of the Wolff algorithm. Inputs:\n\nlattice::StackedDiamondLattice: Lattice to evolve. This function is specialized for the stacked diamond lattice.\nprobdict::Dictionary{Float64, Float64}: Probability of adding the a spin to the cluster. Maps the bond (or edge) strength to the probability.\nadjacentmap::Dictionary{Int64, Vector{Int64}}: Adjacency map of the system. Will be changed to use the adjacency matrix.\n\n\n\n\n\n","category":"method"},{"location":"index.html#HierarchicalLattices.jl","page":"Home","title":"HierarchicalLattices.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This library provides several functions to generate hierarchical lattices (Griffiths, Kaufman). The primary idea to do this is to define a transformation on a part of a graph and then iterate said transformation across all the subgraphs. This library utilizes Graphs.jl to construct graphs and MetaGraphs.jl to store spin metadata on the vertices and bond strength on the edges. At the moment, this library also includes implementations of the Metropolis and Wolff algorithms for simulating spin-1/2 Ising systems on these lattices, however this will be moved to a separate library in the future. Implementations and interfaces are in a nascent stage, thus expect breaking changes in both. At the moment, only the diamond hierarchical lattice has been implemented.","category":"page"},{"location":"index.html#Code-structure","page":"Home","title":"Code structure","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"For every lattice type, it's implementation will be stored in src/NameLattice. Any MCMC algorithm can also be stored in this directory. At the moment the DiamondLattice implements lattice generation methods in Lattice.jl","category":"page"},{"location":"index.html#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"warning: Warning\nThis documentaiton may be out of date if breaking commits are made after 29 May, 2023. Raise an issue in such a case.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"warning: Warning\nThis library currently has a plotting recipe for a MetaGraph, which means it can clash with another graph plotting library implementing the same. Use with caution.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"There are two main data structures exported for the diamond lattice, the DiamondLattice and StackedDiamondLattice types. Refer to the doc strings for how to use each function. A typical use case of simulating a lattice can be as follows.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> using HierarchicalLattices\n\njulia> order = 5; b = 2; initstate = :zero\n:zero\n\njulia> lattice = DiamondLattice(diamond_ising_lattice(order, b, initstate), order)\nDiamondLattice(5, {684, 1024} undirected Int64 metagraph with Float64 weights defined by :weight (default weight 1.0), {684, 1024} undirected Int64 metagraph with Float64 weights defined by :weight (default weight 1.0), 1.0)\n\njulia> ID = IsingData(lattice, Float64[], Float64[], Int64[])\nIsingData(DiamondLattice(5, {684, 1024} undirected Int64 metagraph with Float64 weights defined by :weight (default weight 1.0), {684, 1024} undirected Int64 metagraph with Float64 weights defined by :weight (default weight 1.0), 1.0), Float64[], Float64[], Int64[])\n\njulia> metropolis!(ID, 1000, 1.64)\n\njulia> ID.lattice.initial_state.vprops\nDict{Int64, Dict{Symbol, Any}} with 684 entries:\n  319 => Dict(:val=>1)\n  185 => Dict(:val=>1)\n  420 => Dict(:val=>1)\n  525 => Dict(:val=>1)\n  365 => Dict(:val=>1)\n  638 => Dict(:val=>1)\n  263 => Dict(:val=>1)\n  422 => Dict(:val=>1)\n  242 => Dict(:val=>1)\n\njulia> ID.lattice.final_state.vprops\nDict{Int64, Dict{Symbol, Any}} with 684 entries:\n  319 => Dict(:val=>1)\n  185 => Dict(:val=>1)\n  420 => Dict(:val=>-1)\n  525 => Dict(:val=>1)\n  365 => Dict(:val=>1)\n  638 => Dict(:val=>1)\n  263 => Dict(:val=>1)\n  422 => Dict(:val=>1)\n  242 => Dict(:val=>-1)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Similar usage for a StackedDiamondLattice can be seen (this time with the Wolff algorithm).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> using HierarchicalLattices\n\njulia> order = 5; depth = 15; stackingweight = 1.5; initstate = :zero\n:zero\n\njulia> stackedlattice = StackedDiamondLattice(order, depth, stackingweight, initstate)\nStackedDiamondLattice(5, 1.5, {10260, 24936} undirected Int64 metagraph with Float64 weights defined by :weight (default weight 1.0), {10260, 24936} undirected Int64 metagraph with Float64 weights defined by :weight (default weight 1.0), Dict(4986 => Dict(1.5 => [4302, 5670], 1.0 => [4789, 4845]), 7329 => Dict(1.5 => [6645, 8013], 1.0 => [6860, 6975]), 4700 => Dict(1.5 => [4016, 5384], 1.0 => [4137, 4250]), 4576 => Dict(1.5 => [3892, 5260], 1.0 => [4122, 4160]), 7144 => Dict(1.5 => [6460, 7828], 1.0 => [6845, 6950]), 6073 => Dict(1.5 => [5389, 6757], 1.0 => [5506, 5619]), 2288 => Dict(1.5 => [1604, 2972], 1.0 => [2054, 2128]), 1703 => Dict(1.5 => [1019, 2387], 1.0 => [1375, 1494]), 1956 => Dict(1.5 => [1272, 2640], 1.0 => [1400, 1492]), 8437 => Dict(1.5 => [7753, 9121], 1.0 => [8210, 8281])…))\n\njulia> WD = WolffData(lattice = stackedlattice, magnetization_history=Float64[], internalenergy_history=Float64[], thermalization_steps=1000, saveinterval=20)\nWolffData{StackedDiamondLattice}(StackedDiamondLattice(5, 1.5, {10260, 24936} undirected Int64 metagraph with Float64 weights defined by :weight (default weight 1.0), {10260, 24936} undirected Int64 metagraph with Float64 weights defined by :weight (default weight 1.0), Dict(4986 => Dict(1.5 => [4302, 5670], 1.0 => [4789, 4845]), 7329 => Dict(1.5 => [6645, 8013], 1.0 => [6860, 6975]), 4700 => Dict(1.5 => [4016, 5384], 1.0 => [4137, 4250]), 4576 => Dict(1.5 => [3892, 5260], 1.0 => [4122, 4160]), 7144 => Dict(1.5 => [6460, 7828], 1.0 => [6845, 6950]), 6073 => Dict(1.5 => [5389, 6757], 1.0 => [5506, 5619]), 2288 => Dict(1.5 => [1604, 2972], 1.0 => [2054, 2128]), 1703 => Dict(1.5 => [1019, 2387], 1.0 => [1375, 1494]), 1956 => Dict(1.5 => [1272, 2640], 1.0 => [1400, 1492]), 8437 => Dict(1.5 => [7753, 9121], 1.0 => [8210, 8281])…)), Float64[], Float64[], 20, 1000)\n\njulia> wolff!(WD, 100, 1.64; showprogress = true)\nProgress: 100%|████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| Time: 0:02:31 ( 0.15  s/it)\nProgress: 100%|████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| Time: 0:00:14 ( 0.15  s/it)\n([-29469.0, -29387.0, -29486.0, -29497.0, -29386.0], [10194.0, 10176.0, 10204.0, 10202.0, 10174.0])","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The StackedDiamondLattice constructor can construct a MetaGraph that is stacking diamond lattices and provides you with a single resulting MetaGraph. This has the advantage that, for the most part, the algorithms do not change, and one can just implement the algorithms for a general MetaGraph with spin stored in the :val property and interaction strength stored in the edge weight (if nonexistent, then this is the default weight of the graph edges).","category":"page"}]
}
